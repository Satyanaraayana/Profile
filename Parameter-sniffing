Parameter Sniffing is a common performance issue in SQL Server. 
It occurs when a stored procedure or query with parameters is compiled using one specific set of parameter values, 
and the resulting execution plan is reused for all subsequent executions‚Äîregardless of the actual parameter values. 
If the initial parameter values are not representative of the typical workload, the reused plan can cause poor performance.
________________________________________
üîç What Happens During Parameter Sniffing? 
1.	SQL Server compiles a stored procedure or parameterized query.
2.	It "sniffs" (reads) the initial parameter values during compilation.
3.	It creates an execution plan optimized for those values.
4.	The same plan is reused for future calls‚Äîeven if future parameter values would perform better with a different plan.
________________________________________
‚ö†Ô∏è Problem Example: Parameter Sniffing
Suppose you have this table:
CREATE TABLE Orders (
    OrderID INT IDENTITY,
    CustomerID INT,
    OrderDate DATE
);
CREATE INDEX IX_CustomerID ON Orders(CustomerID);

Now, create this stored procedure:
CREATE PROCEDURE GetOrdersByCustomer
    @CustomerID INT
AS
BEGIN
    SELECT * FROM Orders WHERE CustomerID = @CustomerID;
END;
Usage scenario:
‚Ä¢	First execution: EXEC GetOrdersByCustomer @CustomerID = 1
‚Üí Suppose Customer 1 has 10,000 rows ‚Üí SQL Server may choose a Clustered Index Scan.
‚Ä¢	Second execution: EXEC GetOrdersByCustomer @CustomerID = 999
‚Üí Suppose Customer 999 has only 1 row ‚Üí But SQL Server reuses the scan plan, which is inefficient for just one row.
________________________________________
‚úÖ Solutions to Mitigate Parameter Sniffing
1. OPTION (RECOMPILE) ‚Äì Recompile for every execution
CREATE PROCEDURE GetOrdersByCustomer
    @CustomerID INT
AS
BEGIN
    SELECT * FROM Orders WHERE CustomerID = @CustomerID
    OPTION (RECOMPILE);
END;
‚Ä¢	Forces SQL Server to generate a new plan every time using current parameter values.
‚Ä¢	‚úÖ Good for procedures with high variability.
‚Ä¢	‚ùå More CPU usage due to frequent compilations.
________________________________________
2. Use Local Variables ‚Äì Break sniffing behavior
CREATE PROCEDURE GetOrdersByCustomer
    @CustomerID INT
AS
BEGIN
    DECLARE @LocalCustomerID INT = @CustomerID;

    SELECT * FROM Orders WHERE CustomerID = @LocalCustomerID;
END;
‚Ä¢	Local variables prevent SQL Server from sniffing the parameter.
‚Ä¢	The optimizer assumes unknown value (average stats), leading to generic plans.
________________________________________
3. Optimize for Specific Value ‚Äì Guide the optimizer
SELECT * FROM Orders
WHERE CustomerID = @CustomerID
OPTION (OPTIMIZE FOR (@CustomerID = 999));
‚Ä¢	You can also use:
OPTION (OPTIMIZE FOR UNKNOWN)
to force SQL Server to use average distribution.
________________________________________
4. Plan Guides (Advanced)
‚Ä¢	Useful when you can‚Äôt modify code but want to influence the plan.
‚Ä¢	Often used by DBAs on legacy codebases.
________________________________________
5. Query Store + Automatic Plan Correction (SQL Server 2017+)
‚Ä¢	Use Query Store to monitor regressions.
‚Ä¢	SQL Server can automatically revert to a better-performing plan.

